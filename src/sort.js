/*
 * STEP: 1 挿入ソート
 *  挿入ソートは、データ列を「整列済み」と「未整列」の2つに分け、「未整列な配列」からデータを1つ取り出し、
 *  整列済み配列」の適切な位置に挿入することを繰り返す手法です。「未整列な配列」が空になるまで処理を繰り返すと、
 *  1つの「整列済み配列」が得られます。この手法は、手持ちのトランプを並び替える際などによく用いられる、自然で比較的直感的なものです。
 *  挿入ソート (昇順) は以下のようなアルゴリズムです。初期状態では A[0] ~ A[0] を「整列済み」、A[1] ~ A[n-1] を「未整列」とします。
 *    insertion_sort(A : 配列, n : Aの要素数)
 *       for i = 1 to n-1
 *          // A[i] を、整列済みの A[0] ~ A[i-1] の適切な位置に挿入する
 *          
 *          // 実装の都合上、A[i] の値が上書きされてしまうことがあるので、予め A[i] の値をコピーしておく        
 *          x <- A[i]
 *          
 *          // A[i] の適切な挿入位置を表す変数 j を用意
 *          j <- i-1
 *          
 *          // A[i] の適切な挿入位置が見つかるまで、A[i] より大きい要素を1つずつ後ろにずらしていく
 *          while j >= 0 AND A[j] > x
 *              A[j+1] = A[j]
 *              j--
 *          
 *          // A[i] を挿入
 *          A[j+1] <- x
 *          
 *          // A[0] ~ A[i] が整列済みになった
 *  挿入ソートの計算量を考えます。最も多くの計算ステップがかかるのは、while ループ中で値をずらす処理です。
 *  よって、この処理が最大で何回行われるかに注目し、計算量を導きます。各 i について、while ループ中で値をずらす処理は最大で i 回行われます。
 *  つまり、最悪の場合この処理は全体で 1 + 2 + ... + n-1 = (n-1)*n/2 = (n^2-n)/2 回行われます。よって、挿入ソートは O(n^2) のアルゴリズムとなります。
 *  挿入ソートは、入力される配列によって効率が変わるアルゴリズムです。例えば、入力される配列が予め昇順にソートされている場合は値をずらす処理が
 *  全く行われませんが、降順にソートされている場合は (n^2-n)/2 回行われます。
 *  では、要素数 n の数列を昇順にソートする挿入ソートのプログラムを作成してください。上の疑似コードに従って実装してください。
 *  アルゴリズムが正しく実装されていることを確認するために、各 i についてその処理が終わった時点での配列を出力してください。
 */
function step1(){
  //var lines = [5,'4 1 3 5 2']
  var lines = [5,'-9247 8112 1394 56 -574']
  var N = Number.parseInt(lines[0])
  var ary = lines[1].split(' ')
  
  for(var i=1; i<N; i++){
    var x = Number.parseInt(ary[i])
    var j = i-1
    while(j>=0 && Number.parseInt(ary[j])>x){
      ary[j+1] = ary[j]
      j--
    }
    ary[j+1] = x
    print(ary, N)
  }  
}
function print(ary, N){
  var str = ''
  for(var i=0; i<N; i++){
    if(i>0){
      str = str + ' ' + ary[i]
    }else{
      str = str + ary[i]
    }
  }
  console.log(str)
}
//step1()

/*
 * STEP: 2 選択ソート
 *  選択ソート (昇順) は、データ列を「整列済み」と「未整列」の2つに分け、「未整列な配列」の最小値を取り出し、
 * 「整列済み配列」の末尾に付け加えることを繰り返す手法です。「未整列な配列」の要素数が 1 になるまで処理を繰り返すと、
 *  1つの「整列済み配列」が得られます。
 *  選択ソート (昇順) は以下のようなアルゴリズムです。初期状態では配列全体 A[0] ~ A[n-1] を「未整列」とします。
 *  selection_sort(A : 配列, n : Aの要素数)
 *    for i = 0 to n-2
 *        // A[i] ~ A[n-1] の最小値を見つけ、A[i]と交換する
 *        // つまり、整列済みとなっている A[0] ~ A[i-1] の末尾に、A[i] ~ A[n-1] の最小値を付け加える
 *        
 *        // A[i] ~ A[n-1] の最小値の位置を保存する変数 min_index を用意
 *        // 暫定的に A[i] を最小値とする
 *        min_index <- i
 *  
 *        // 最小値を探す
 *        for j = i+1 to n-1
 *            if A[j] < A[min_index] then
 *                min_index = j
 *  
 *        // A[i] と A[min_index]を交換
 *        swap(A[i], A[min_index])
 *  
 *        // A[0] ~ A[i] が整列済みになった
 *  選択ソートの計算量を考えます。最も多くの計算ステップがかかるのは、二重 for ループ中にて値を比較する処理です。
 *  よって、この処理が何回行われるかに注目し、計算量を導きます。この処理は、各 i について n-i-1 回行われます。
 *  つまり、この処理は全体で n-1 + ... + 1 = (n-1)*n/2 = (n^2-n)/2 回行われます。よって、選択ソートは O(n^2) のアルゴリズムとなります。
 *  選択ソートは、入力によって効率が左右されないアルゴリズムです。
 *  では、要素数 n の数列を昇順にソートする選択ソートのプログラムを作成してください。上の疑似コードに従って実装してください。
 *  アルゴリズムが正しく実装されていることを確認するために、各 i についてその処理が終わった時点での配列を出力してください。
 */
function step2(){
  var lines = [5,'4 1 3 5 2']
  var N = Number.parseInt(lines[0])
  var ary = lines[1].split(' ')
  
  for(var i=0; i<N-1; i++){
    var minIndex = i
    for(var j=i+1; j<N; j++){
      if(Number.parseInt(ary[j]) < Number.parseInt(ary[minIndex])){
        minIndex = j
      }
    }
    var min = ary[minIndex]
    ary[minIndex] = ary[i]
    ary[i] = min
    print(ary, N)
  }  

}
//step2()